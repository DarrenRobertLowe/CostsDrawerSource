<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>PARENT_rightColumnScrollbars</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal Scrollbar Vars
list                = global.WITNESSES;
get_right_column_text_width(list);


minWidth            = global.scrollbarMinHeight;
height              = global.scrollbarButtonSize;

buttonWidth         = global.scrollbarButtonSize;
scrollAreaStartX    = global.rightColumnWindowsX1 + buttonWidth;
scrollAreaEndX      = global.rightColumnWindowsX2 - buttonWidth;

scrollAreaWidth     = (scrollAreaEndX - scrollAreaStartX);


/// INITIALIZE JUST IN CASE ///
mouse_pos = (window_mouse_get_x() - x);
scrollbarPosition = 0;

// start the step event
alarm[0] = 2;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// find width of scroll area (not the scroll bar iteslf)

scrollAreaStartX    = global.rightColumnWindowsX1 + buttonWidth;
scrollAreaEndX      = global.rightColumnWindowsX2 - buttonWidth;
scrollAreaWidth     = (scrollAreaEndX - scrollAreaStartX);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// find the width of the scroll bar itself (not the scroll area)

/* setup */
var maxWidth = scrollAreaWidth;

// find the scrollbar width
width = ( maxWidth /( textWidth/maxWidth) );        // lovely bit of math.
width = floor(width);


// constrain the width
if (width &gt; maxWidth) then width = maxWidth;
if (width &lt; minWidth) then width = minWidth;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// position the scrollbar's X to the current character
if (dragging == false)
{
    // calculate the position of the scrollbar
    var scrollableDistance      = (scrollAreaWidth - width);                                // the scrollbar itself takes up an amount of the scroll area
    
    // adjust for whitespace
    var maxChars  = (scrollAreaWidth / charWidth)
    var adjustedTextLength = (textLength - (maxChars-2));                                   // otherwise we get a window's worth of whitespace at the end.
    ////
    
    // NOTE: myScroll is determined by the child objects
    var percentagePosition      = (myScroll / adjustedTextLength)                           // get the percentage
    
    
    var position                = floor(scrollableDistance * percentagePosition);           // the actual scrollbar position
    scrollbarPosition           = position;    // needs to be a class var for dragging
    
    x  = ( scrollAreaStartX + scrollbarPosition );
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// check if scrollbar should be displayed
if (textWidth &gt; scrollAreaWidth)
{
    scrollbarShown = true;
}
else
{
    scrollbarShown = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// check if scrollbar should be displayed
if (textWidth &gt;= scrollAreaWidth)
{
    scrollbarShown = true;
}
else
{
    scrollbarShown = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw the scroll bar

if (scrollbarShown)
{
    if (mouseOver == true)
        {
        draw_set_color(global.scrollbarColorDark)  // dark gray
        }
    else
        {
        draw_set_color(global.scrollbarColorLight) // light gray
        }

    draw_rectangle(x, y, (x + width), (y + height), 0);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// mouse hover and click events
if (scrollbarShown)
{
    // before dragging
    if (dragging == false)
    {
        // MOUSE OVER SCROLLBAR ITEELF
        if ( mouseOverScrollbar() )
        {
            mouseOver = true;
            
            if mouse_check_button_pressed(mb_left)
            {
                dragging = true;
                mouse_pos = (window_mouse_get_x() - x);
            }
        }
        
        // MOUSE OVER GENERAL SCROLLBAR AREA
        else if ( mouseOverScrollArea_H() )
        {
            if ( mouse_check_button_pressed(mb_left) )
            {
                x = ( window_mouse_get_x()-(width/2) );                 // center on the mouse

                constrain_scrollbarH();
                myScroll = get_right_column_xview_from_scrollbar();
                exit;                                                   // avoid running the dragging event
            }
        }
        else mouseOver = false; // mouse over nothing
    }
    
    
    // while dragging
    if (dragging == true)
    {
        x = ( window_mouse_get_x() - mouse_pos );
        constrain_scrollbarH();
        myScroll = get_right_column_xview_from_scrollbar();
    }
    
    
    // finished dragging
    if ( mouse_check_button_released(mb_left) )
    {
        dragging = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
