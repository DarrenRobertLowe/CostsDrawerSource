<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// SETUP and HTTP_GET
/* This object is responsible for checking for updates,
 * and for downloading and installing updates, as well
 * as drawing the progress bar for the download.
 */

r_str            = "null";
updateStatus     = -1;                  // 0 is failed, 1 is success
versionStr       = "";
checkstring      = "Current Version ";
online           = true;
checkedForUpdate = false;               // whether or not we've already checked for an update



/// GET WEBPAGE TEXT
updateCheck             = -1;                   // http_get(WEBSITE);
connectionCheck         = http_get(WEBSITE);    // "http://www.google.ie");
connectionCheckTimer    = 0;
httpUpdateFile          = -1;


show_debug_message("requested http data");


// downloading update
httpUpdateFile          = -1;
file                    = -1;
downloadingUpdate       = false;
sizeDownloaded          = 1;            //-1; DEBUG
contentLength           = 1000000;      //-1; DEBUG
maxSize                 = 400;
downloadPermission      = -1;
permissionToDownload    = false;
updateRequestTimer      = 0;


// transfer speed polling
poll_timer           = 0;
pollRate             = 4;
transferSpeed        = 0;
prevSizeDownloaded   = 0;
averageTransferSpeed = 0;
reset_download_transferSpeed_array();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// DOWNLOAD / CHECK CONNECTION / UPDATE FAILED?

/// CHECK FOR CONNECTION
if (room == OPENING_SCREEN)
{
    if ( (get_timer()/1000) &gt; connectionCheckTimer)
    {
        connectionCheckTimer = ((get_timer()/1000) + 3000); // check for a connection every 3 seconds
        
        if os_is_network_connected()
        {
            online = true;
            connectionCheck = http_get(WEBSITE);
        }
        else
        {
            online = false;
            show_debug_message("************************************* COSTS DRAWER IS OFFLINE");
        }
    }
}



/// UPDATE FAILED?
if (updateStatus == 0)
{
    show_message("Update failed. Please try again later. #If this problem persist, please contact technical support.");
    updateStatus = -1;
    
    // replace missing exe file after messing up
    //var exe_name = (string_replace(game_display_name," ","_") +".exe");
    var origFile = (program_directory + EXE_NAME);
    //show_message("origFile : "+string(origFile));
                                                                    //show_message("DEBUG: Remove original exe now");
    if !( file_exists(origFile) )
    {
        show_debug_message("No original exe file found!");
        write_log("No original exe file found!");
        
        
        var appdataFolder   = get_appdata_folder();
        var backupFile      = (appdataFolder + "\backup");
                                                                    //show_message("DEBUG: About to check for backup file");
        if ( file_exists(backupFile) )
        {
            show_debug_message("Replacing missing exe with backup");
            write_log("Replacing missing exe with backup");
            file_copy_win(backupFile, origFile);
            
            // check that it's there
            if ( file_exists(origFile) )
            {
                show_debug_message("Replaced the missing .exe successfully!");
                write_log("Replaced the missing .exe successfully!");
            }
            else
            {
                show_debug_message("Original exe is still missing even after replacing. Costs Drawer may need to be reinstalled!");
                write_log("Original exe is still missing even after replacing. Costs Drawer may need to be reinstalled!");
            }
        }
        else
        {
            show_message("Error: Updating: No 'backup' file found, cannot replace exe! Costs Drawer may need to be reinstalled!");
            write_log("No backup file found, cannot replace missing exe! Costs Drawer may need to be reinstalled!");
        }
    }
}


// DOWNLOAD
if (permissionToDownload == true)
{
    if ((get_timer()/1000) &gt; updateRequestTimer)
    {
        if (downloadingUpdate == false)
        {
            retrieve_update_file();
            updateRequestTimer = (get_timer()/1000 + 5000);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="63">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// GET DOWNLOAD PERMISSION

var i_d;
i_d = ds_map_find_value(async_load, "id");

if (i_d == downloadPermission)
{
    if (ds_map_find_value(async_load, "status") &gt; 0) //== true)
    {
        show_debug_message("permissionToDownload granted!");
        write_log("User confirmed wanting to download....");
        //url_open(WEBSITE +"updating.html");
        permissionToDownload = true;
        room_goto(OPENING_SCREEN);
    }
    else
    {
        show_debug_message("User denied download permission.");
        write_log("User denied download permission.");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="62">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// REQUEST RETURN / UPDATE
/* NOTE:
 * The Website should have the updated version number
 * as a comment in the header. This can be accessed 
 * on the web builder in the
 *    "PAGES &gt; SEO &gt; Header HTML" section. 
 * This was done so that we can remove references to
 * Costs Drawer from the website if we want, and it
 * will still work as long as the comment is kept 
 * up to date.
*/

/// REGULAR CONNECTION CHECK
if (ds_map_find_value(async_load, "id") == connectionCheck)
{
    if (ds_map_find_value(async_load, "status") &gt;= 0)       // connected
    {
        global.online = true;
        
        if (checkedForUpdate == false)
        {
            updateCheck = http_get(WEBSITE);                // check for update
        }
    }
}


/// SCRAPE NEW VERSION INFO
if (ds_map_find_value(async_load, "id") == updateCheck)
{
    if (ds_map_find_value(async_load, "status") == 0)                       // we're connected
    {
        debug_message("CHECKING FOR UPDATES...");
        
        // we have to grab the text AFTER "Current Version "
        r_str           = ds_map_find_value(async_load, "result");
        var pos         = string_pos(checkstring,r_str);                    // checkstring = "Current Version "
        var skipChars   = string_length(checkstring);
        pos += skipChars;
        if (pos &gt; skipChars) then versionStr = string_copy(r_str, pos, 7);
        global.latestVersionString = versionStr;  // used by OPENING_SCREEN_MASTER to show a new update is available
        
        
        // perform the comparison
        global.newVersionAvailable = update_compare_version(versionStr);      
        
        // download?
        if (global.newVersionAvailable == true)
        {
            /* NOTE: For some reason asking for permission causes the async event to not trigger.
             *       At first I though it was caused by show_question() interrupting the process,
             *       but even using show_question_async() resulted in the same issue. It's like it
             *       times out... or something. There's a 0.95MB file returned and it never downloads.
             *
             *       The fix was to change room back to opening_screen after accepting permission.
             */
            debug_message("An update is available!");
            downloadPermission = show_question_async("A new version of Costs Drawer (version "+string(versionStr)+") is available. Do you want to download and install this now?")
        }
        else 
        {
            debug_message("Costs Drawer is up to date");
            update_check_if_just_updated();
        }
                                          
    }
    
    if (ds_map_find_value(async_load, "status") == -1)                      // there's no connection
    {
        global.online = false;
        show_debug_message("Could not connect to webserver to check for updates. Either Costs Drawer is offline, or the website is down.");
        write_log("Could not connect to webserver to check for updates. Either Costs Drawer is offline, or the website is down.");
    }
}


/// UPDATE PROGRESS
if (ds_map_find_value(async_load, "id") == httpUpdateFile)
{
    // SETUP
    var status = ds_map_find_value(async_load, "status");
    sizeDownloaded  = ds_map_find_value(async_load, "sizeDownloaded");
    contentLength   = ds_map_find_value(async_load, "contentLength");
    
    
    // DOWNLOADING UPDATE
    if (status == 1)
    {
        downloadingUpdate = true;
        permissionToDownload = false;
    }
    
    // FINISHED DOWNLOAD SUCCESSFULLY
    if  (status == 0)       
    and (updateStatus != 0) // and nothing went wrong...
    {
        debug_message("global.UPDATE_LINK = "+string(global.UPDATE_LINK));
        
        // RUN THE INSTALLER
        //if (string_letters(global.UPDATE_FORMAT) == "installer")
        //{
            update_run_installer();
            
            // close the program if it's safe to do so
            if (room == OPENING_SCREEN)
            {
                debug_message("Exiting Costs Drawer");
                game_end();
            }
            if (room == WINDOW)
            {
                debug_message("Cannot exit Costs Drawer automatically, user has a document open.");
                show_message("The download is complete, you must save your work and close Costs Drawer before updating!");
            }
        //}
        //else if (string_letters(global.UPDATE_FORMAT) == "exe")
        //{
        //    debug_message("UPDATING AS EXE ONLY");
        //    update_exe_format();
        //}
        //else
        //{
        //    debug_message("Could not determine download format! Cancelling update.");
        //   exit;
        //}
        
        reset_download_transferSpeed_array();
    }
    
    
    // ERROR AFTER STARTING DOWNLOAD
    if  (status == 0)
    and (updateStatus == 0) // something went wrong along the way
    {
        debug_message("Finished download, but something went wrong during it, so cancelling update process.");
    }
    
    
    // ERROR
    if (status &lt; 0)
    {
        debug_message("ERROR! Problem connecting to server");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw the download progress bar or No Connection warning
//draw_text(0,0,"version "+string(GM_version));

draw_set_font(font_GUI_large);


if  (online == false)
and (room == OPENING_SCREEN)
{
    draw_set_valign(fa_middle);
    draw_set_color(c_red);
    draw_text(15, window_get_height()-20, "No internet - Cannot check for updates!");
}


//downloadingUpdate = true; // DEBUG (offline download simulation)

if  (downloadingUpdate == true)
and (!is_undefined(contentLength))
and (!is_undefined(sizeDownloaded))
and (contentLength &gt; 0)
and (sizeDownloaded &gt; 0)
{
    poll_download_transferSpeed(sizeDownloaded);
    var remainingTime   = get_download_remainingTime_string(contentLength, sizeDownloaded, transferSpeed);
    
    var len = maxSize;
    
    // downloading update
    windowHeight            = window_get_height();
    progressBarHeight       = 30;
    progressBarStartY       = ( windowHeight - (progressBarHeight+3) );
    progressBarEndY         = ( progressBarStartY + progressBarHeight );
    progressBarStartYGreen  = (progressBarStartY + 1);
    progressBarEndYGreen    = (progressBarEndY - 1);
    maxSize                 = 400;
    var contentLengthKB     = ((contentLength  /1024)/1024);
    var sizeDownloadedKB    = ((sizeDownloaded /1024)/1024);
    var transferSpeedKB     = (averageTransferSpeed/1024);
    
    draw_set_color(c_black);
    draw_rectangle(1, progressBarStartY, 1+len, progressBarEndY, false);
    
    if  (contentLength  &gt; 0)
    and (sizeDownloaded &gt; 0)
    {
        len = ( (maxSize / contentLength) * sizeDownloaded );
        
        draw_set_color(c_green);
        draw_rectangle(1, progressBarStartYGreen, 1+len, progressBarEndYGreen, false);
         
        draw_set_color(c_white);
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        
        draw_set_font(font_GUI);
        draw_text(200, progressBarEndY-15, string(sizeDownloadedKB) +"MB of " +string(contentLengthKB)+"MB : " +string(transferSpeedKB)+"KB/sec : "+string(remainingTime) +" remaining");
    }
}

reset_text();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
